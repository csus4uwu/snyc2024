典题
===

本文记录简单但经典的思路和技巧。
---

> 算法：二分、递归递推（搜索）、前缀和

---

- 给 $n$ 个区间，每个区间为 $[l_i, r_i]$，问有多少对区间有交集。

<details>

> abc355_d

两个区间 $i, j$ 没有交集，当且仅当 $l_j > r_i$ 或 $l_i > r_j$，即一个区间的左端点大于另一个区间的右端点。

因此对右端点排序。对于每个左端点 $l_i$，二分寻找比它小的右端点的数量，加起来即为没有交集的区间对数量。

或者不分离左右端点，以左端点为关键字排序后，用扫描线扫过去统计。

</details>


---
- 给一棵带边权的无根树，求经过所有点至少一次的最短路径（起点终点任意）。

<details>

>abc361_e

如果起点和终点一样，容易想到过程为“出去，再回来”，路径长度为边长和的两倍。

起点终点任意，最优的过程为“出去，到最后一个点停止”，比上述情况少了“从最后一个点回来”的步骤，也就是说，结果为边长和的两倍减去某一条路径的长度。

要使结果最优，减去的路径长度就要最长，显然就是树的直径。

因此两次 dfs 求出直径即可。

</details>


---
- 有一座岛，可以看成一个 $n\cdot m$ 的网络，每个格子都有一个给定的高度 $h_{i, j}$。

    刚开始海平面为 $0$，每年上涨 $1$，问 $1, 2, \dots ,A$ 年的时候，岛屿没被海水没过的土地面积（即有多少格子）。

<details>

>abc363_e

每年都搜索一次的复杂度无法接受。

考虑用堆优化。预先将边缘存入一个小根堆中进行 bfs，一年一年看，对于某年海水淹没的所有边缘格子，将他们周围的格子放进堆中。复杂度 $O(n^2 \log (n^2))$ 级别。

详见 [submission](https://atcoder.jp/contests/abc363/submissions/57625023)

</details>


---

- 序列 $123456789101112131415161718\dots$ 是无穷无尽的，输出它的第 $k$ 项。

<details>

> $\rm cf1177b$

先定位整的（位数），再找零的。

这种思路在计数题目中的应用很广泛，比如找第 $k$ 个回文数（或者符合某些性质的数或串）。

</details>


---

- 给定 $a, b, c$，从 $0$ 开始，每次可以 $+a$ 或 $+b$，可以操作任意次，问最后和 $c$ 的差的最小值。

<details>

[$\rm{Bezouts}$ 定理](https://oiwiki.com/math/number-theory/bezouts)

题目中的操作等价于 $+\gcd(a, b)$。令 $g = \gcd(a, b)$，结果为 $c \bmod g$。

结论可从 $a, b$ 推广至 $n$ 个数。

</details>


---

- Alice 和 Bob 手上有 1~n 的牌，从 Alice 先开始轮流打牌。
当一张卡片被打到桌面上后，如果到目前为止已打出的卡片上数字的总和能被 m 整除，刚刚出牌的人输。
如果全打完了没分出胜负，则 Alice 赢。
    > 要求 $O\left(1\right)$

<details>

[原题](https://atcoder.jp/contests/arc185/tasks/arc185_a)

注意到：对于任一方，手牌数大于 1 时，均不会立刻输掉比赛。（因为 n < m，如果打出一张牌不行，那么打另外一张肯定行）

所以判断 Alice 最后一张牌出完之后的形势就行。
如果 1~n 的和能被 m 整除，则 bob 出完最后一张牌就输了；
如果 1~n 的和大于 m，则全打完了也不分胜负，仍然 alice 赢。

</details>


---
