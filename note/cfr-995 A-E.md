## A

如果取 $a_i$，就要取 $b_{i + 1}$，要最大化 $\text{sum}_a - \text{sum}_b$，那么当 $a_i > b_{i + 1}$，就可以取这俩，需要注意边界。

## B

先除以三个的和，取整数部分，然后对模分类讨论即可。

## C

如果 $k = n$，即所有题都知道，那每一套题都能过；

如果 $k < n - 1$，因为每套题都有 $n - 1$ 道，每一套题都过不了；

剩下 $k = n - 1$ 的情况，只需要检查会的题目中是否有不考的题，如果有，那就过不了这套题。

实现方面，用桶数组或 $\texttt {std::set}$ 即可。

## D

将题目的条件转化一下：

$$
x \leq \text{sum} - a_i - a_j \leq y \\
\text{sum} - a_i - y \leq a_j \leq \text{sum} - a_i - x
$$

那么可以二分对每个元素统计其贡献。我的方法是：对每个元素，先判断和它自己是不是满足条件，然后二分查找上界和下界，最后将统计的和减半就是答案。

代码见 [链接](https://codeforces.com/contest/2051/submission/297964726)。

## E

挺好的关于线段的维护问题。

将每个人的 $[a_i, b_i]$ 看作一条线段。考虑以一种方式遍历这些线段：当新加进来一条线段，表示买但是给差评的人多了一个；退出一条线段，则表示买的人和给差评的人都减少了一个，因为不买的人也不会给差评。对于每次加入或退出线段，都更新一次答案。

一种做法是：给每个端点打上标记，分辨是不是起点。将端点从小到大排序之后遍历。

一种较为简洁方法是：设 $c$ 为买的人数，$x$ 为买且给差评的人数。初始时价格最低，所有人都会买而且不会给差评，当遍历到起点，有 $x\leftarrow x+1$；遍历到终点则有 $c\leftarrow c-1$ 和 $x\leftarrow x - 1$。每遍历一个新的值时，若 $x \leq k$，更新一次答案。

代码见 [链接](https://codeforces.com/contest/2051/submission/297959039)。